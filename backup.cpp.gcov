        -:    0:Source:src/backup.cpp
        -:    0:Graph:src/backup.gcno
        -:    0:Data:src/backup.gcda
        -:    0:Runs:1
        -:    1:#include "backup.hpp"
        -:    2:#include <cassert>
        -:    3:#include <fstream>
        -:    4:#include <cstring>
        -:    5:#include <sys/stat.h>
        -:    6:#include <time.h>
        -:    7:
        -:    8:
        -:    9:/** 
        -:   10: * @brief  faz o backup de um arquivo listado em Backup.parm
        -:   11: * @author Bernardo Pimentel
        -:   12: * @param  caminho_backup_parm caminho do arquivo Backup.parm
        -:   13: * @param  caminho_destino caminho do destino onde o arquivo de interesse será copiado
        -:   14: * 
        -:   15: * Assertivas de entrada:
        -:   16: *      caminho_backup_parm != NULL
        -:   17: *      caminho_destino != NULL
        -:   18: *        assert(stat_destino.st_mtime > stat_pendrive.st_mtime)
        -:   19: * 
        -:   20: */ 
        -:   21:
        4:   22:int Salvar(const char *caminho_backup_parm, const char *caminho_destino) {
       4*:   23:    assert(caminho_backup_parm != nullptr);
       4*:   24:    assert(caminho_destino != nullptr);
        -:   25:
        4:   26:    FILE *backup_parm = fopen(caminho_backup_parm, "r");
        4:   27:    if (backup_parm == NULL) {
        1:   28:        return 1; // arquivo inexistente
        -:   29:    }
        -:   30:
        3:   31:    FILE * arquivo_destino = fopen(caminho_destino, "r");
        3:   32:    if (arquivo_destino == NULL) {
        1:   33:        return 1; // arquivo inexistente
        -:   34:    }
        -:   35:
        -:   36:    // copia arquivo para o pendrive pt 1:
        2:   37:    const char *nome_arquivo = strrchr(caminho_destino, '/');
        2:   38:    if (nome_arquivo == NULL) {
    #####:   39:        nome_arquivo = caminho_destino;
        -:   40:    } else {
        2:   41:        nome_arquivo++; // pula a barra
        -:   42:    }
        -:   43:
        -:   44:    char caminho_no_pendrive[512];
        2:   45:    snprintf(caminho_no_pendrive, sizeof(caminho_no_pendrive), "tests/fixtures/pendrive_simulado/%s", nome_arquivo);
        -:   46:    // copiar arquivo para o pendrive pt 1
        -:   47:
        -:   48:    // Comparar idade do arquivo no pendrice com no HD:
        2:   49:    FILE* arquivo_no_pendrive = fopen(caminho_no_pendrive, "rb");
        2:   50:    if (!(arquivo_no_pendrive == NULL)) {
        -:   51:        struct stat stat_destino;
        -:   52:        struct stat stat_pendrive;
        -:   53:
        -:   54:        // stats do caminho destino
        1:   55:        if (stat(caminho_destino, &stat_destino) != 0) {
    #####:   56:            return 1;
        -:   57:        }
        -:   58:        // stats do caminho pendrive
        1:   59:        if (stat(caminho_no_pendrive, &stat_pendrive) != 0) {
    #####:   60:            return 1;
        -:   61:        }
        -:   62:
        -:   63:        // garantir q hd é mais velho
        1:   64:        if (stat_destino.st_mtime > stat_pendrive.st_mtime) {
    #####:   65:            return 1;
        -:   66:        }
        -:   67:    }
        -:   68:
        -:   69:
        -:   70:    // copiar arquivo para o pendrive pt 2
        2:   71:    FILE *arquivo_saida = fopen(caminho_no_pendrive, "wb");
        2:   72:    if (arquivo_saida == NULL) {
    #####:   73:        fclose(arquivo_destino);
    #####:   74:        fclose(backup_parm);
    #####:   75:        return 1; // erro ao criar arquivo de saída
        -:   76:    }
        -:   77:
        -:   78:    // Copia o conteúdo de arquivo_destino para arquivo_saida
        -:   79:    char buffer[4096];
        -:   80:    size_t bytes;
        3:   81:    while ((bytes = fread(buffer, 1, sizeof(buffer), arquivo_destino)) > 0) {
        1:   82:        fwrite(buffer, 1, bytes, arquivo_saida);
        -:   83:    }
        -:   84:    // copia arquivo para o pendrive pt 2.
        -:   85:    
        2:   86:    fclose(arquivo_saida);
        2:   87:    fclose(arquivo_destino);
        2:   88:    fclose(backup_parm);
        -:   89:
        -:   90:    // Aqui você pode fazer o que for necessário com o arquivo aberto.
        -:   91:    // Exemplo: copiar para outro local (caminho_destino), etc.
        2:   92:    return 0; // sucesso
        -:   93:}
        -:   94:
        -:   95:/** 
        -:   96: * @brief  restaura um arquivo listado em Backup.parm
        -:   97: * @author Bernardo Pimentel
        -:   98: * @param  caminho_backup_parm caminho do arquivo Backup.parm
        -:   99: * @param  caminho_fonte caminho do destino onde o arquivo de interesse será restaurado
        -:  100: * 
        -:  101: *  Descrever o que a funcao faz
        -:  102: */ 
        -:  103:
        1:  104:int Restaurar(const char *caminho_backup_parm, const char *caminho_fonte) {
       1*:  105:    assert(caminho_backup_parm != nullptr);
       1*:  106:    assert(caminho_fonte != nullptr);
        -:  107:
        1:  108:    FILE *backup_parm = fopen(caminho_backup_parm, "r");
        1:  109:    if (backup_parm == NULL) {
    #####:  110:        return 1; // erro: arquivo não existe
        -:  111:    }
        -:  112:
        1:  113:    FILE * arquivo_fonte = fopen(caminho_fonte, "r");
        1:  114:    if (arquivo_fonte == NULL) {
        1:  115:        return 1;
        -:  116:    }
        -:  117:
        -:  118:    // Aqui você pode fazer o que for necessário com o arquivo aberto.
        -:  119:    // Exemplo: copiar para outro local (caminho_destino), etc.
        -:  120:
    #####:  121:    fclose(arquivo_fonte);
    #####:  122:    fclose(backup_parm);
    #####:  123:    return 0; // sucesso
        -:  124:}
